<!DOCTYPE html>
<html lang="en">
<head>
    <title>Production server</title>
    <!--<script src="vflex_frontend/js/werewolf_comms.js"></script>
    <script src="vflex_frontend/js/werewolf_comms_leds.js"></script>
    <script src="vflex_frontend/js/werewolf_util.js"></script>
    <script src="vflex_frontend/js/werewolf_connect.js"></script>
    <script type="module" src="vflex_frontend/js/vflex_lib.js"></script>-->
    <style>
        #outputLog {
            width: 300px;
            height: 200px;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-y: auto; /* adds scrollbar when content overflows */
            white-space: pre-wrap; /* preserves line breaks */
        }
    </style>
</head>
<body>

    <script type="module">
        import {VFLEX_COMMANDS,VFLEX_API} from "../js/vflex_lib.js"
        let vflex = new VFLEX_API();
        let pdos_ws;
        window.pdos_ws_path = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/pdos`;

        var encrypted_msg = 0;
        function waitForACK(){
            return new Promise((resolve) => {
                const interval = setInterval(() => {
                    if(ACK) {
                        ACK = 0;
                        clearInterval(interval);
                        resolve();
                    }
                }, 25);
            });
        }
        async function waitForEncryptedMsg(){
            return new Promise((resolve) => {
                const interval = setInterval(() => {
                    if(encrypted_msg) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 25);
            });
        }
        async function waitForConnectRxComplete(){
            return new Promise((resolve) => {
                const interval = setInterval(() => {
                    if(devce_contents_loaded) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 25);
            });
        }
 
        async function waitForSerial(){
            return new Promise((resolve) => {
                const interval = setInterval(() => {
                    if (vflex.device_data.serial_num !== null && vflex.device_data.serial_num !== '') {
                        clearInterval(interval);
                        resolve();
                    }
                }, 25);
            });
        }

        async function waitForValue(propertyName) {
            return new Promise((resolve) => {
                const interval = setInterval(() => {
                    if (vflex.device_data[propertyName] !== null && vflex.device_data[propertyName] !== undefined && vflex.device_data[propertyName] !== '') {
                        clearInterval(interval);
                        resolve();
                    }
                }, 25);
            });
        }
        function addToLog(message) {
            const log = document.getElementById('outputLog');
            log.textContent += `${message}\n`;
            log.scrollTop = log.scrollHeight;
        }


        async function vflex_status(){
          if (!vflex.connected){
            console.log('no');
            return;
          } else {
            await vflex.get_voltage_mv();
            addToLog(`voltage: ${vflex.device_data['voltage_mv']}`);

          }
        }
        async function waitForConnected(timeoutMs = 5000) {
          return new Promise((resolve, reject) => {
              const startTime = Date.now();
              const checkInterval = setInterval(() => {
                  if (connected) {
                      clearInterval(checkInterval);
                      resolve(true);
                  } else if (Date.now() - startTime >= timeoutMs) {
                      clearInterval(checkInterval);
                      reject(new Error('Timeout waiting for connection'));
                  }
              }, 100);
          });
        }

        document.addEventListener('DOMContentLoaded', function() {
            const pdos_ws_path = window.pdos_ws_path || 'http://localhost:8005'; // check for server path provided from index.html, localhost default
            console.log(pdos_ws_path);
            //const pdos_ws  = new WebSocket(pdos_ws_path);
            pdos_ws  = new WebSocket(pdos_ws_path);
            pdos_ws.onmessage = function(event){
              encrypted_msg = JSON.parse(event.data);
              console.log("data:", encrypted_msg);
            };

            //try {pdos_ws.send(JSON.stringify({N: 2, V_MV : 9000}));}
            //catch (error) {console.log(error);}

            vflex.on('connect', async () => {
              vflex_status();
            });

            connectButton.addEventListener('click', function() {
              vflex.app_autoconnect();
            });
            clear_pdo_log_btn.addEventListener('click', function() {
              vflex.clear_pdo_log();
            });
            send_pdo_log_btn.addEventListener('click', function() {
              try {pdos_ws.send(JSON.stringify({N: 2, V_MV : 9000}));}
              catch (error) {console.log(error);}
              console.log('ok?');
            });

            console.log("go");
        });
    </script>

    <div><input id="connectButton" type="button" value="connect"/></div>
    <div><input id="clear_pdo_log_btn" type="button" value="clear pdo log"/></div>
    <div><input id="send_pdo_log_btn" type="button" value="send pdo log"/></div>
    _________________________________________<br><br>
    <div id="outputLog"></div>
</body>
</html>
